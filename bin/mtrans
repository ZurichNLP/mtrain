#!/usr/bin/env python3

import fileinput
import logging
import argparse
import sys
import os
import tempfile
import datetime

from mtrain.translation import TranslationEngineBase, TranslationEngineMoses, TranslationEngineNematus
from mtrain.constants import *
from mtrain import checker

def get_argument_parser():
    parser = argparse.ArgumentParser()
    parser.description = ("Translates text using a Moses-based or Nematus-based machine " +
        "translation system trained with `mtrain`.")

    # positional arguments for either backend
    parser.add_argument(
        "basepath",
        type=str,
        help="base path of the machine translation system, i.e., the output " +
        "directory (-o) used in `mtrain`."
    )
    parser.add_argument(
        "src_lang",
        type=str,
        help="source language code: valid choices are `" +
            "`, `".join([lang for lang in sorted(MOSES_TOKENIZER_LANG_CODES.keys())]) +
            "`",
        choices=MOSES_TOKENIZER_LANG_CODES.keys(),
        metavar='src_lang' # overrides ugly double-listing of available choices in '--help'
    )
    parser.add_argument(
        "trg_lang",
        type=str,
        help="target language code: same valid choices as in src_lang",
        choices=MOSES_TOKENIZER_LANG_CODES.keys(),
        metavar='trg_lang' # overrides ugly double-listing of available choices in '--help'
    )

    # optional arguments for either backend
    parser.add_argument(
        "--backend", # '-b' removed as it would conflict with '--bpe_ops'
        type=str,
        help="indicate which backend was used as training engine in `mtrain`." +
            " Valid choices are: " +
            "; ".join(["`%s`: %s" % (name, descr) for name, descr in BACKEND_CHOICES.items()]),
        choices=BACKEND_CHOICES.keys(),
        default='moses'
    )
    parser.add_argument(
        "--logging",
        help="logging level in STDERR, default=`DEBUG`",
        choices=LOGGING_LEVELS.keys(),
        default="DEBUG"
    )

    # arguments specific for moses backend ###BH todo revise
    # (consider moving argument to section 'optional arguments for either backend' if implemented accordingly)
    moses_args = parser.add_argument_group("Moses arguments")

    moses_args.add_argument(
        "--xml_input",
        type=str,
        help="decide how XML fragments in the input segments should " +
            "be dealt with. Valid choices are: " +
            "; ".join(["`%s`: %s" % (name, descr) for name, descr in XML_STRATEGIES.items()]),
        choices=XML_STRATEGIES.keys()
    )
    moses_args.add_argument(
        "-l", "--lowercase",
        help="lowercase translated segments",
        default=False,
        action='store_true'
    )
    moses_args.add_argument(
        "--skip_preprocess",
        help="do not preprocess segments at all before translation",
        default=False,
        action="store_true"
    )
    moses_args.add_argument(
        "--skip_detokenize",
        help="do not detokenize segments after translation",
        default=False,
        action="store_true"
    )

    # arguments specific for nematus backend ###BH todo revise
    # (consider moving argument to section 'optional arguments for either backend' if implemented accordingly)
    nematus_args = parser.add_argument_group("Nematus arguments")

    nematus_args.add_argument(
        "--device_trans",
        type=str,
        help="choose a free processing unit for nematus translation, consult your server responsible " +
            "to learn about appropriate settings"
        ###BH todo # do NOT set default as it would trigger warning for backend moses. settings are server specific, thus enforced from user.
    )
    nematus_args.add_argument(
        "--preallocate_trans",
        type=str,
        help="preallocate processing unit memory for nematus translation if applicable on your server. " +
            "Do not preallocate more than `0.2` = 20 percent of memory. " +
            "The system will automatically use more memory if available and safe."
        ###BH todo # do NOT set default as it would trigger warning for backend moses. settings are server specific, thus enforced from user.
    )
    nematus_args.add_argument(
        "--adjust_dictionary",
        help="Ensure dictionary paths in model config (model.npz.json located in model basepath) match the .json files " +
            "in the basepath's corpus folder. Necessary when models were trained in a path different than " +
            "the current basepath. If paths are not matching, nematus returns an empty string for any translation " +
            "without error message OR may use the wrong .json files for translation.",
        default=False,
        action="store_true"
    )
    nematus_args.add_argument(
        "--keep_translation",
        help="In addition to being printed to the terminal, keep a copy of the translated text " +
        "which is appended to the translation file stored in your base directory.",
        default=False,
        action="store_true"
    )

    return parser

###BH todo test and check if complete
def check_environment_nematus():
    '''
    Abort if environment variables specific for nematus backend are not set.
    '''
    checker.check_environment_variable(NEMATUS_HOME, 'NEMATUS_HOME', 'nematus')
    checker.check_environment_variable(SUBWORD_NMT_HOME, 'SUBWORD_NMT_HOME', 'subword-nmt')

###BH todo implement and test
def check_arguments_nematus(args):
    '''
    Check for arguments if fit for nematus, either combination or specific argument may
    be not (yet) applicable for the backend. Depending on severity, user is warned and maybe
    program terminated.

    @param args all arguments passed from 'get_argument_parser()'
    '''

def create_tempfiles_nematus():
    '''
    Create temporary directory and secure named temporary files.
    ###BH check reference cf. https://security.openstack.org/guidelines/dg_using-temporary-files-securely.html
    '''
    tempdir = tempfile.mkdtemp()
    mtrans_temp_pre = 'mtrans.tmp.pre'
    mtrans_temp_trans = 'mtrans.tmp.trans'
    # path to named temp files needed for passing to translation engine
    temp_pre = os.path.join(tempdir, mtrans_temp_pre)
    temp_trans = os.path.join(tempdir, mtrans_temp_trans)
    return tempdir, temp_pre, temp_trans

def preprocess_input_nematus(temp_pre, engine):
    '''
    Preprocess segments and store in temp file.

    @param temp_pre path to temporary file where preprocessed segments are stored
    @param engine object holding the nematus translation engine providing preprocessing,
        translation and postprocessing functionality
    '''
    with open(temp_pre, 'a') as f_pre:
        for line in sys.stdin: # read stdin
            source_segment = line.strip()
            if source_segment != '':
                # call preprocessing routine for each input segment
                preprocessed_segment = engine.preprocess(source_segment)
                preprocessed_segment = preprocessed_segment.rstrip()
                f_pre.write(preprocessed_segment + '\n')
    f_pre.close()

def postprocess_translation_nematus(args, temp_trans, engine):
    '''
    Postprocess segments by reading from translated temp file.
    Also prepares final translation file and stores output if user chose so.
    '''
    # if chosen by user, set up translation file for storing output
    if args.keep_translation:
        translation_file = args.basepath + '/translation.txt'
        with open(translation_file, 'a') as f_out:
            # write identifying translation title and timestamp
            ###BH check reference # cf. https://www.saltycrane.com/blog/2008/06/how-to-get-current-date-and-time-in/
            now = datetime.datetime.now()
            f_out.write("\nINFO: Your `%s` input translated to `%s` using backend %s, %s:\n\n" % (args.src_lang, args.trg_lang, args.backend, now.strftime("%Y-%m-%d %H:%M:%S")))
        f_out.close()

    # postprocess segments, return to console and store if chosen by user
    with open(temp_trans, 'r') as f_trans:
        for line in f_trans:
            trans_segment = line.strip()
            if trans_segment != '':
                # call postprocessing routine for each translated segment
                postprocessed_segment = engine.postprocess(trans_segment)
                postprocessed_segment = postprocessed_segment.rstrip()
                # print result (translated and postprocessed segment) to console
                print(postprocessed_segment)
                # storing result in translation file if chosen by user
                if args.keep_translation:
                    with open(translation_file, 'a') as f_out:
                        f_out.write(postprocessed_segment + '\n')
                    f_out.close()
    f_trans.close()

    # inform user where to find translation file
    if args.keep_translation:
        print("\nINFO: `%s` translation stored in file %s\n" % (args.trg_lang, translation_file))

def cleanup_tempfiles_nematus(tempdir, temp_pre, temp_trans):
    '''
    Delete temporary directory and secure named temporary files.
    ###BH check reference cf. https://security.openstack.org/guidelines/dg_using-temporary-files-securely.html
    '''
    os.remove(temp_pre)
    os.remove(temp_trans)
    os.rmdir(tempdir)

def main():
    parser = get_argument_parser()
    args = parser.parse_args()
    # initialize logging (stderr)
    console = logging.StreamHandler()
    console.setLevel(LOGGING_LEVELS[args.logging])
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console.setFormatter(formatter)
    logging.getLogger("").addHandler(console)

    # distinguish chosen backend
    if args.backend == BACKEND_MOSES:

        # instantiating moses translation engine
        ###BH @MM: positional args 'uppercase_first_letter' and 'quiet' were missing
        ###old line was: engine = TranslationEngine(args.basepath, args.src_lang, args.trg_lang, xml_strategy=args.xml_input)
        ###possibly resulting in 'xml_strategy=args.xml_input' passed to 'uppercase_first_letter=False' when creating instance of TranlationEngine
        engine = TranslationEngineMoses(args.basepath, args.src_lang, args.trg_lang, uppercase_first_letter=False, xml_strategy=args.xml_input, quiet=False)
        print("\nINFO: Translating `%s` input to `%s` using backend %s:" % (args.src_lang, args.trg_lang, args.backend))
        for line in sys.stdin: # read stdin
            source_segment = line.strip()
            if source_segment != '':
                translation = engine.translate(
                    source_segment,
                    preprocess=not(args.skip_preprocess),
                    lowercase=args.lowercase,
                    detokenize=not(args.skip_detokenize)
                )
                # uppercase translation's first letter if first letter in source_segment is uppercased
                if not args.lowercase and source_segment[0].isupper():
                    translation = translation[0].upper() + translation[1:]
                print(translation)

    # distinguish chosen backend
    if args.backend == BACKEND_NEMATUS:
        '''
        ###BH todo add reference for general approach when translating with nematus model:
        wmt instructions https://github.com/rsennrich/wmt16-scripts/blob/master/sample/README.md
        '''
        # abort if environment variables for nematus backend are not set
        check_environment_nematus()

        # check if arguments suiting nematus
        check_arguments_nematus(args)

        # create temporary directory and secure named temporary files
        tempdir, temp_pre, temp_trans = create_tempfiles_nematus()

        # instantiating nematus translation engine
        engine = TranslationEngineNematus(args.basepath, args.src_lang, args.trg_lang, args.adjust_dictionary)
        print("\nINFO: Translating `%s` input to `%s` using backend %s:\n" % (args.src_lang, args.trg_lang, args.backend))

        # preprocess segments and store in temp file
        preprocess_input_nematus(temp_pre, engine)

        # translate preprocessed segments as whole text using temp files:
        # as each call of nematus' translate.py takes time to initialize cpu/gpu/cuda,
        # segment by segment translation would result in significant loss of time
        engine.translate(args.device_trans, args.preallocate_trans, temp_pre, temp_trans)

        # postprocess segments by reading from translated temp file
        postprocess_translation_nematus(args, temp_trans, engine)

        # cleanup temp files and temp dir
        cleanup_tempfiles_nematus(tempdir, temp_pre, temp_trans)

if __name__ == '__main__':
    # abort if Python version is not supported
    checker.check_python_version()
    # abort if environment variables necessary for either backend are not set
    # (check env variables specific for a backend in respective method)
    checker.check_environment_variable(MOSES_HOME, 'MOSES_HOME', 'moses')
    # run main routine
    main()
