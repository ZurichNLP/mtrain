#!/usr/bin/env python3

import fileinput
import logging
import argparse
import sys
import os
import datetime

from mtrain.translation import TranslationEngineBase, TranslationEngineMoses, TranslationEngineNematus
from mtrain.constants import *
from mtrain import checker

def get_argument_parser():
    parser = argparse.ArgumentParser()
    parser.description = ("Translates text using a Moses-based or Nematus-based machine " +
        "translation system trained with `mtrain`.")

    # positional arguments for either backend
    parser.add_argument(
        "basepath",
        type=str,
        help="base path of the machine translation system, i.e., the output " +
        "directory (-o) used in `mtrain`."
    )
    parser.add_argument(
        "src_lang",
        type=str,
        help="source language code: valid choices are `" +
            "`, `".join([lang for lang in sorted(MOSES_TOKENIZER_LANG_CODES.keys())]) +
            "`",
        choices=MOSES_TOKENIZER_LANG_CODES.keys(),
        metavar='src_lang' # overrides ugly double-listing of available choices in '--help'
    )
    parser.add_argument(
        "trg_lang",
        type=str,
        help="target language code: same valid choices as in src_lang",
        choices=MOSES_TOKENIZER_LANG_CODES.keys(),
        metavar='trg_lang' # overrides ugly double-listing of available choices in '--help'
    )

    # optional arguments for either backend
    parser.add_argument(
        "--backend", # '-b' removed as it would conflict with '--bpe_ops'
        type=str,
        help="indicate which backend was used as training engine in `mtrain`." +
            " Valid choices are: " +
            "; ".join(["`%s`: %s" % (name, descr) for name, descr in BACKEND_CHOICES.items()]),
        choices=BACKEND_CHOICES.keys(),
        default='moses'
    )
    parser.add_argument(
        "--logging",
        help="logging level in STDERR, default=`DEBUG`",
        choices=LOGGING_LEVELS.keys(),
        default="DEBUG"
    )

    # arguments specific for moses backend ###BH todo revise
    # (consider moving argument to section 'optional arguments for either backend' if implemented accordingly)
    moses_args = parser.add_argument_group("Moses arguments")

    moses_args.add_argument(
        "--xml_input",
        type=str,
        help="decide how XML fragments in the input segments should " +
            "be dealt with. Valid choices are: " +
            "; ".join(["`%s`: %s" % (name, descr) for name, descr in XML_STRATEGIES.items()]),
        choices=XML_STRATEGIES.keys()
    )
    moses_args.add_argument(
        "-l", "--lowercase",
        help="lowercase translated segments",
        default=False,
        action='store_true'
    )
    moses_args.add_argument(
        "--skip_preprocess",
        help="do not preprocess segments at all before translation",
        default=False,
        action="store_true"
    )
    moses_args.add_argument(
        "--skip_detokenize",
        help="do not detokenize segments after translation",
        default=False,
        action="store_true"
    )

    # arguments specific for nematus backend ###BH todo revise
    # (consider moving argument to section 'optional arguments for either backend' if implemented accordingly)
    nematus_args = parser.add_argument_group("Nematus arguments")

    nematus_args.add_argument(
        "--device_trans",
        type=str,
        help="choose a free processing unit for nematus translation, consult your server responsible " +
            "to learn about appropriate settings"
        ###BH todo # do NOT set default as it would trigger warning for backend moses. settings are server specific, thus enforced from user.
    )
    nematus_args.add_argument(
        "--preallocate_trans",
        type=str,
        help="preallocate processing unit memory for nematus translation if applicable on your server. " +
            "Do not preallocate more than `0.2` = 20 percent of memory. " +
            "The system will automatically use more memory if available and safe."
        ###BH todo # do NOT set default as it would trigger warning for backend moses. settings are server specific, thus enforced from user.
    )
    nematus_args.add_argument(
        "--adjust_dictionary",
        help="Ensure dictionary paths in model config (model.npz.json located in model basepath) match the .json files " +
            "in the basepath's corpus folder. Necessary when models were trained in a path different than " +
            "the current basepath. If paths are not matching, nematus returns an empty string for any translation " +
            "without error message OR may use the wrong .json files for translation.",
        default=False,
        action="store_true"
    )
    nematus_args.add_argument(
        "--keep_translation",
        help="In addition to being printed to the terminal, keep a copy of the translated text " +
        "which is appended to the translation file stored in your base directory.",
        default=False,
        action="store_true"
    )

    return parser

def main():
    parser = get_argument_parser()
    args = parser.parse_args()
    # initialize logging (stderr)
    console = logging.StreamHandler()
    console.setLevel(LOGGING_LEVELS[args.logging])
    formatter = logging.Formatter('%(asctime)s - %(levelname)s - %(message)s')
    console.setFormatter(formatter)
    logging.getLogger("").addHandler(console)

    # distinguish chosen backend
    if args.backend == BACKEND_MOSES:

        # instantiating moses translation engine
        ###BH @MM: positional args 'uppercase_first_letter' and 'quiet' were missing
        ###old line was: engine = TranslationEngine(args.basepath, args.src_lang, args.trg_lang, xml_strategy=args.xml_input)
        ###possibly resulting in 'xml_strategy=args.xml_input' passed to 'uppercase_first_letter=False' when creating instance of TranlationEngine
        engine = TranslationEngineMoses(args.basepath, args.src_lang, args.trg_lang, uppercase_first_letter=False, xml_strategy=args.xml_input, quiet=False)
        print("\nINFO: Translating '%s' input to '%s' using backend %s:" % (args.src_lang, args.trg_lang, args.backend))
        for line in sys.stdin: # read stdin
            source_segment = line.strip()
            if source_segment != '':
                translation = engine.translate(
                    source_segment,
                    preprocess=not(args.skip_preprocess),
                    lowercase=args.lowercase,
                    detokenize=not(args.skip_detokenize)
                )
                # uppercase translation's first letter if first letter in source_segment is uppercased
                if not args.lowercase and source_segment[0].isupper():
                    translation = translation[0].upper() + translation[1:]
                print(translation)

    # distinguish chosen backend
    if args.backend == BACKEND_NEMATUS:
        '''
        ###BH todo add reference for general approach when translating with nematus model:
        wmt instructions https://github.com/rsennrich/wmt16-scripts/blob/master/sample/README.md
        '''
        # setting up temporary files for translation
        path_temp_files = '/tmp'
        temp_pre = path_temp_files + '/mtrans.tmp.pre'
        temp_trans = path_temp_files + '/mtrans.tmp.trans'
        # setting up translation file path for storing output if chosen
        translation_file = args.basepath + '/translation.txt'

        # cleanup: remove temp files from previous translation attempts e.g. when program terminated
        ###BH check reference # cf. https://security.openstack.org/guidelines/dg_using-temporary-files-securely.html
        try:
            os.remove(temp_pre)
        except FileNotFoundError:
            pass
        try:
            os.remove(temp_trans)
        except FileNotFoundError:
            pass

        # instantiating nematus translation engine
        engine = TranslationEngineNematus(args.basepath, args.src_lang, args.trg_lang, args.adjust_dictionary)
        print("\nINFO: Translating '%s' input to '%s' using backend %s:\n" % (args.src_lang, args.trg_lang, args.backend))

        # preprocess segments and store in temp file
        with open(temp_pre, 'a') as f_pre: ###
            for line in sys.stdin: # read stdin
                source_segment = line.strip()
                if source_segment != '':
                    preprocessed_segment = engine.preprocess(source_segment)
                    preprocessed_segment = preprocessed_segment.rstrip()
                    f_pre.write(preprocessed_segment + '\n')
        f_pre.close()

        # translate preprocessed segments as whole text using temp files:
        # as each call of nematus' translate.py takes time to initialize cpu/gpu/cuda,
        # segment by segment translation would result in significant loss of time
        engine.translate(args.device_trans, args.preallocate_trans, temp_pre, temp_trans)

        if args.keep_translation:
            with open(translation_file, 'a') as f_out:
                # write info and timestamp to translation file if chosen
                ###BH check reference # cf. https://www.saltycrane.com/blog/2008/06/how-to-get-current-date-and-time-in/
                now = datetime.datetime.now()
                f_out.write("\nINFO: Your '%s' input translated to '%s' using backend %s, %s:\n\n" % (args.src_lang, args.trg_lang, args.backend, now.strftime("%Y-%m-%d %H:%M:%S")))
            f_out.close()

        # postprocess segments by reading from translated temp file
        with open(temp_trans, 'r') as f_trans:
            for line in f_trans:
                trans_segment = line.strip()
                if trans_segment != '':
                    postprocessed_segment = engine.postprocess(trans_segment)
                    postprocessed_segment = postprocessed_segment.rstrip()
                    print(postprocessed_segment)

                    # storing output if chosen
                    if args.keep_translation:
                        with open(translation_file, 'a') as f_out:
                            f_out.write(postprocessed_segment + '\n')
                        f_out.close()
        f_trans.close()

        # inform user where to find translation file
        if args.keep_translation:
            print("\nINFO: '%s' translation stored in file %s\n" % (args.trg_lang, translation_file))

        # cleanup: remove temp files
        os.remove(temp_pre)
        os.remove(temp_trans)

if __name__ == '__main__':
    # abort if Python version is not supported
    checker.check_python_version()
    # abort if environment variables necessary for either backend are not set
    # (check env variables specific for a backend in respective method)
    checker.check_environment_variable(MOSES_HOME, 'MOSES_HOME', 'moses')
    # run main routine
    main()
