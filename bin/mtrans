#!/usr/bin/env python3

"""
Command line interface for translation.
"""

import sys
import os
import tempfile

from mtrain.translation import TranslationEngineMoses, TranslationEngineNematus
from mtrain import constants as C
from mtrain import checker
from mtrain.arguments import get_translation_parser, check_environment, check_trans_arguments
from mtrain.utils import set_up_logging, infer_backend


def perform_checks(args):
    """
    Check python version, environment, arguments.
    """
    # abort if Python version is not supported
    checker.check_python_version()
    # abort if environment variables are not set
    check_environment(args)
    # abort if arguments are incompatible
    check_trans_arguments(args)


def create_tempfiles_nematus():
    """
    Create temporary directory and secure named temporary files.
    Cf. https://security.openstack.org/guidelines/dg_using-temporary-files-securely.html
    """
    tempdir = tempfile.mkdtemp()
    mtrans_temp_pre = 'mtrans.tmp.pre'
    mtrans_temp_trans = 'mtrans.tmp.trans'
    # path to named temp files needed for passing to translation engine
    temp_pre = os.path.join(tempdir, mtrans_temp_pre)
    temp_trans = os.path.join(tempdir, mtrans_temp_trans)
    return tempdir, temp_pre, temp_trans

def preprocess_input_nematus(temp_pre, engine):
    """
    Preprocesses segments and stores them in temp file.

    @param temp_pre path to temporary file where preprocessed segments are stored
    @param engine object holding the nematus translation engine providing preprocessing,
        translation and postprocessing functionality
    """
    with open(temp_pre, 'a') as f_pre:
        for line in sys.stdin: # read stdin
            source_segment = line.strip()
            if source_segment != '':
                # call preprocessing routine for each input segment
                preprocessed_segment = engine.preprocess_segment(source_segment)
                preprocessed_segment = preprocessed_segment.rstrip()
                f_pre.write(preprocessed_segment + '\n')
    f_pre.close()

def postprocess_translation_nematus(temp_trans, engine):
    """
    Postprocesses segments by reading from translated temp file.
    Also prepares final translation file.
    """
    # postprocess segments, display on console and store if chosen by user
    with open(temp_trans, 'r') as f_trans:
        for line in f_trans:
            trans_segment = line.strip()
            if trans_segment != '':
                # call postprocessing routine for each translated segment
                postprocessed_segment = engine.postprocess_segment(trans_segment)
                postprocessed_segment = postprocessed_segment.rstrip()

                sys.stdout.write(postprocessed_segment + '\n')


def cleanup_tempfiles_nematus(tempdir, temp_pre, temp_trans):
    """
    Deletes temporary directory and secure named temporary files.
    """
    os.remove(temp_pre)
    os.remove(temp_trans)
    os.rmdir(tempdir)

def main():
    """
    Main translation interface.
    """
    parser = get_translation_parser()
    args = parser.parse_args()

    perform_checks(args)
    set_up_logging(args, mode="translate")

    args.backend = infer_backend(args)

    # distinguish chosen backend
    if args.backend == C.BACKEND_MOSES:

        # instantiating moses translation engine
        engine = TranslationEngineMoses(basepath=args.basepath,
                                        src_lang=args.src_lang,
                                        trg_lang=args.trg_lang, uppercase_first_letter=False, xml_strategy=args.xml_input, quiet=False)

        for line in sys.stdin: # read stdin
            source_segment = line.strip()
            if source_segment != '':
                translation = engine.translate(
                    source_segment,
                    preprocess=not(args.skip_preprocess),
                    lowercase=args.lowercase,
                    detokenize=not(args.skip_detokenize)
                )
                # uppercase translation's first letter if first letter in source_segment is uppercased
                if not args.lowercase and source_segment[0].isupper():
                    translation = translation[0].upper() + translation[1:]
                    sys.stderr.write(translation + '\n')

    # distinguish chosen backend
    elif args.backend == C.BACKEND_NEMATUS:

        # create temporary directory and secure named temporary files
        tempdir, temp_pre, temp_trans = create_tempfiles_nematus()

        engine = TranslationEngineNematus(args.basepath, args.src_lang, args.trg_lang, args.adjust_dictionary)

        # preprocess segments and store in temp file
        preprocess_input_nematus(temp_pre, engine)

        # translate preprocessed segments as whole text using temp files:
        # as each call of nematus' translate.py takes time to initialize cpu/gpu/cuda,
        # segment by segment translation would result in significant loss of time
        engine.translate(args.device_trans, args.preallocate_trans, temp_pre, temp_trans)

        # postprocess segments by reading from translated temp file
        postprocess_translation_nematus(temp_trans, engine)

        # cleanup temp files and temp dir
        cleanup_tempfiles_nematus(tempdir, temp_pre, temp_trans)

if __name__ == '__main__':
    main()
